877. 石子游戏

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。



**示例：**

> **输入**：[5,3,4,5]  
> **输出**：true  
> **解释**：  
> 亚历克斯先开始，只能拿前 5 颗或后 5 颗石子。  
> 假设他取了前 5 颗，这一行就变成了 [3,4,5]。  
> 如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。  
> 如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。  
> 这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true。 



**提示：**

* 2 <= piles.length <= 500
* piles.length 是偶数。
* 1 <= piles[i] <= 500
* sum(piles) 是奇数。



**解析：**

博弈型动态规划，从第一步进行分析必胜态、必败态。首先难点是如何定义状态，如果定义状态为获胜与否，状态转移公式为 $(dp[i][j] = !(dp[i+1][j]\  ||\ dp[i][j-1])$ ，会发现无法利用 $piles[i]$ 这一有效信息，此外无法记录当前选手持子数量。

为了定义这个相对获胜的概念，我们想到，可以通过定义两人持子数量的差值作为状态，当前持子差值为正，说明当前选手持子数量多于另一选手，相对获胜。反之亦然。

在此基础上再来看状态转移方程，因为只涉及选择头部或是尾部，而当前选手应考虑将当前持子差值最大化，因此状态转移方程应为 $dp[i][j] = Max(piles[i] - dp[i+1][j],\ piles[j] - dp[i][j-1])$ 。

再考虑初始状态及边界条件，当 $i<j$ 时，上述状态转移方程成立；当 $i=j$ 时，即选手面前只有一堆石子时，他只拿走该堆石子，此时持子差值为该堆石子数量。当 $i>j$ 时，出界，无意义。

最后考虑计算顺序，对于整个 $dp$ 矩阵只需计算上三角部分，从对角线初始化，进而计算次对角线，依次类推。两重循环时，$i$ 应该由大到小遍历， $j$ 应该由 $i+1$ 遍历至边界。



**代码：**

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n = piles.length;
        int[][]dp = new int[n][n];
        for (int i=0; i<n; ++i) {
            dp[i][i] = piles[i];
        }
        for (int i=n-2; i>=0; --i) {
            for (int j=i+1; j<n; ++j) {
                dp[i][j] = Math.max(piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]);
            }
        }
        return dp[0][n-1] > 0;
    }
}
```



**优化：**

可以通过滚动数组对空间复杂度进行进一步优化，$dp[i][j]$ 的计算依赖于 $dp[i+1][j]$ 与 $dp[i][j-1]$ 即下方与左侧。



**代码：**

```java
class Solution {
    public boolean stoneGame(int[] piles) {
        int n = piles.length;
        int[]dp = new int[n];
        for (int i=0; i<n; ++i) {
            dp[i] = piles[i];
        }
        for (int i=n-2; i>=0; --i) {
            for (int j=i+1; j<n; ++j) {
                dp[j] = Math.max(piles[i] - dp[j], piles[j] - dp[j-1]);
            }
        }
        return dp[n-1] > 0;
    }
}
```
